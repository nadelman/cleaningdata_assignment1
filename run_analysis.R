##
# This script performs the following functions:
#
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement. 
# 3. Uses descriptive activity names to name the activities in the data set
# 4. Appropriately labels the data set with descriptive activity names. 
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject. 
#
# Writes the first data set (steps 1 through 4 above) to a file named "Human_Activity_Recognition_Dataset1.txt" in the current directory
#
# Writes the first data set (steps 1 through 4 above) to a file named "Human_Activity_Recognition_Dataset2.txt" in the current directory
##
run_analysis <- function(directory) {
  
  colNames <- generateSubjectLabels(directory)
  testSet <- processDirectory(paste(directory,"/test", sep=""), "test")
  trainSet <- processDirectory(paste(directory,"/train", sep=""), "train")
  
  totalDF <- rbind(testSet, trainSet)
  colnames(totalDF) <- colNames
  
  keepCols <- resolveColsToKeep(colNames)
  totalDF <- totalDF[keepCols]
  
  # read the activity labels in
  activityLabels <- generateActivityLabels(directory)
  
  # add an activty column at the end with the correctly labeled activity names based on the y(class) value
  totalDF$activity <- activityLabels[totalDF$class]
  
  # write dataset to output file
  write.table(totalDF, "./Human_Activity_Recognition_Dataset1.txt")
  
  # generate dataset 2
  dataSet2 <- generateMeansDataset(totalDF)
  
  # write second data set to file
  write.table(dataSet2, "./Human_Activity_Recognition_Dataset2.txt")
}

##
# Given the data set created by the run_analysis method, create a second data set containing the
# average of each variable for each combination of subject and activity. This is stored in a new data frame
# which contains the following:
# 
# subject id: the subject's id
# activity: the activity for the observations
# variable: the average of all variable values in the input data set for the corresponding subject and activity
#
# param df: data frame generated by the run_analysis function
##
generateMeansDataset <- function(df) {
  # make sure subject and activity are factors
  df$subject <- as.factor(df$subject)
  df$activity <- as.factor(df$activity)
  
  # get the column names for just the variables
  columnNames <- colnames(df)
  columnNames <- columnNames[!(columnNames %in% c("subject", "class", "activity"))]
  
  # melt the data set to get every measurement for combo of subject + activity
  melted <- melt(df, id=c("subject","activity"), measure.vars=columnNames)
  
  # dcast the melted set to get aggregate means, and return
  final <- dcast(melted, subject + activity ~ variable, mean)
}


##
# reads all of the files in a specific folder, and merges them into the specified data frame
#
# For this data set, the test files will all end with "_test.txt" and the training files
# will all end with "_train.txt". Each folder subtains the following files:
#
# subject_<set id>.txt
# X_<set id>.txt
# Y_<set id>.txt
#
# Each folder contains a subfolder named "Inertial Signal" Contain x, y, and x coordinate information
# for body accellercation, body gyroscopy, and total acceleration (9 file total)
## 
processDirectory <- function(directory, postfix) {
    subjectFile <- paste(directory, '/subject_', postfix, ".txt", sep = "")
    xFile <- paste(directory, '/X_', postfix, ".txt", sep = "")
    yFile <- paste(directory, '/Y_', postfix, ".txt", sep = "")
    
    subject <- read.table(subjectFile, header=FALSE)
    x <- read.table(xFile, header=FALSE)
    y <- read.table(yFile, header=FALSE)
    
    df <- data.frame(subject, x, y)    
}

##
# Determine the indices of all of the columns from the data frame that we would like to keep. This
# includes the columns corresponding to the X and Y files, and any features representing mean (looking for
# the text "mean" or "Mean" in the column header), or representing standard deviation (looking for the text "std"
# in the column header). 
#
# Returns the indexs for all of the columns matching these criteria. Sorts the list of indices in ascending order.
##
resolveColsToKeep <- function(colNames) {
  
  meanCols <-  grep("mean[^Freq]", colNames)
  stdCols <-  grep("std", colNames)
  xCols <- grep("subject", colNames)
  yCols <- grep("class", colNames)
  
  sort.int(c(meanCols, stdCols, xCols, yCols))
}

##
# Create a list of all of the feature names for the data frame, based in most part of the features.txt file
#
# The list returned starts with "subject", followed by all of the features from the features.txt file,
# followed by a "class" column for the y values (activity values)
##
generateSubjectLabels <- function(directory) {
    featureFile <- paste(directory, "//", "features.txt", sep = "")
    features <- read.table(featureFile)
    featureList <- as.list(features[2])
    
    allFeatures <- c("subject")
    
    for(item in featureList) {
        # clean up the column names a bit as we go.
        ft <- as.character(item)
        ft <- gsub("\\()","",ft)
        ft <- gsub("-",".",ft)
        allFeatures <- add.unique(allFeatures, ft)
    }
    
    # the column where the y values will be populated
    allFeatures <- add.unique(allFeatures, "class")
}

##
# Reads in the activity labels file and returns the labels as a vector
##
generateActivityLabels <- function(directory) {
  activityLabelFile <- paste(directory, "//", "activity_labels.txt", sep = "")
  activityLabels <- read.table(activityLabelFile)
  activityLabelList <- as.vector(activityLabels[[2]])
  
}

##
# Utility to combine items as a list, ensuring uniqueness of the elements
##
add.unique<-function(ls1,ls2) {
  ifelse (ls2 %in% ls1, return(ls1) , return(c(ls1,ls2)) )
}

